<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>PDF編集ツール | 安定・高画質版</title>
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">

    <style>
        :root { --primary: #4f46e5; --bg: #f1f5f9; --border: #cbd5e1; --accent: #10b981; }
        body { font-family: 'Noto Sans JP', sans-serif; margin: 0; background: var(--bg); height: 100vh; overflow: hidden; }
        
        /* モード選択 */
        #mode-selection {
            position: fixed; inset: 0; background: #1e293b; z-index: 9999;
            display: flex; flex-direction: column; justify-content: center; align-items: center; color: white;
        }
        .mode-cards { display: flex; gap: 20px; margin-top: 30px; }
        .mode-card {
            background: white; color: #1e293b; padding: 30px; border-radius: 12px; width: 240px;
            text-align: center; cursor: pointer; transition: 0.2s;
        }
        .mode-card:hover { transform: translateY(-5px); background: var(--primary); color: white; }

        header { background: #1e293b; color: white; padding: 10px 20px; display: flex; justify-content: space-between; align-items: center; }
        .hidden { display: none !important; }
        main { display: flex; flex: 1; overflow: hidden; height: calc(100vh - 55px); }

        #merge-view { flex: 1; display: grid; grid-template-columns: 1fr 1fr; gap: 2px; background: #cbd5e1; }
        .column { background: var(--bg); display: flex; flex-direction: column; overflow: hidden; }
        .column-header { padding: 12px; background: white; border-bottom: 1px solid var(--border); }
        .scroll-area { flex: 1; overflow-y: auto; padding: 15px; display: flex; flex-direction: column; align-items: center; }

        /* ページカード */
        .page-card { 
            background: white; border: 3px solid transparent; box-shadow: 0 4px 10px rgba(0,0,0,0.1); 
            width: 95%; max-width: 550px; position: relative; margin-bottom: 10px; cursor: pointer;
        }
        .page-card.selected { border-color: var(--primary); box-shadow: 0 0 15px rgba(79, 70, 229, 0.4); }
        .page-card img { width: 100%; height: auto; display: block; }
        .page-footer { padding: 10px; display: flex; justify-content: space-between; align-items: center; background: #f8fafc; border-top: 1px solid #eee; }
        
        /* 挿入ボタン */
        .insert-divider { width: 100%; display: flex; justify-content: center; padding: 12px 0; }
        .btn-insert-here {
            background: white; border: 2px solid var(--accent); color: var(--accent);
            padding: 8px 24px; border-radius: 25px; font-weight: bold; cursor: pointer;
            transition: 0.2s; opacity: 0.2; pointer-events: none;
        }
        .btn-insert-here.active { opacity: 1; pointer-events: auto; background: var(--accent); color: white; }

        .btn { padding: 8px 16px; border-radius: 6px; border: none; font-weight: bold; cursor: pointer; }
        .btn-extract { background: #f59e0b; color: white; position: relative; z-index: 50; }
        .btn-del { position: absolute; top: 8px; right: 8px; background: #ef4444; color: white; border-radius: 50%; width: 30px; height: 30px; border: none; cursor: pointer; z-index: 100; font-size: 16px; }

        .file-label { display: block; padding: 10px; border: 2px dashed var(--primary); border-radius: 8px; text-align: center; cursor: pointer; color: var(--primary); font-weight: bold; }
        
        /* ローディング */
        #status { position: fixed; inset: 0; background: rgba(0,0,0,0.8); color: white; display: none; z-index: 10000; flex-direction: column; justify-content: center; align-items: center; }
        .spinner { width: 40px; height: 40px; border: 4px solid #f3f3f3; border-top: 4px solid var(--primary); border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 10px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

<div id="mode-selection">
    <h1 style="margin-bottom:10px;">PDF 編集ツール</h1>
    <div class="mode-cards">
        <div class="mode-card" onclick="switchMode('extract')"><h2>1枚抽出</h2><p>ページを選んで保存</p></div>
        <div class="mode-card" onclick="switchMode('merge')"><h2>挿入・結合</h2><p>好きな場所に差し込み</p></div>
    </div>
</div>

<header>
    <button class="btn" style="background:#475569; color:white;" onclick="location.reload()">← メニューに戻る</button>
    <span id="current-mode-title" style="font-weight: bold;"></span>
    <div id="merge-actions" class="hidden">
        <button id="saveMergedBtn" class="btn" style="background:var(--accent); color:white;">完成したPDFを保存</button>
    </div>
</header>

<main>
    <div id="extraction-view" class="column hidden" style="flex:1;">
        <div class="column-header"><label class="file-label">PDFを選択<input type="file" id="extractInput" accept=".pdf" style="display:none;"></label></div>
        <div id="extract-list" class="scroll-area"></div>
    </div>

    <div id="merge-view" class="hidden">
        <div class="column">
            <div class="column-header"><label class="file-label">素材PDFを選択<input type="file" id="sourceInput" accept=".pdf" style="display:none;"></label></div>
            <div id="source-list" class="scroll-area"></div>
        </div>
        <div class="column">
            <div class="column-header"><label class="file-label">ベースPDFを選択<input type="file" id="targetInput" accept=".pdf" style="display:none;"></label></div>
            <div id="target-list" class="scroll-area"></div>
        </div>
    </div>
</main>

<div id="status"><div class="spinner"></div><div id="status-text">処理中...</div></div>

<script>
    const { PDFDocument } = PDFLib;
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    
    const pdfDataMap = new Map();
    let fileIdCounter = 0;
    let selectedSourcePage = null;

    function switchMode(mode) {
        document.getElementById('mode-selection').classList.add('hidden');
        if (mode === 'extract') {
            document.getElementById('extraction-view').classList.remove('hidden');
            document.getElementById('current-mode-title').innerText = '1枚抽出モード';
        } else {
            document.getElementById('merge-view').classList.remove('hidden');
            document.getElementById('merge-actions').classList.remove('hidden');
            document.getElementById('current-mode-title').innerText = 'ページ挿入・結合モード';
        }
    }

    // ファイル読み込み
    const setupInput = (id, container, isExt, isTar) => {
        document.getElementById(id).addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            showStatus('読み込み中...');
            try {
                const buffer = await file.arrayBuffer();
                const fileId = 'f' + (fileIdCounter++);
                pdfDataMap.set(fileId, buffer);
                
                const pdf = await pdfjsLib.getDocument({data: buffer.slice(0)}).promise;
                const targetContainer = document.getElementById(container);
                targetContainer.innerHTML = '';
                if (isTar) targetContainer.appendChild(createInsertDivider());

                for (let i = 1; i <= pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    const viewport = page.getViewport({scale: 1.2});
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.height = viewport.height; canvas.width = viewport.width;
                    await page.render({canvasContext: ctx, viewport: viewport}).promise;
                    
                    const imgData = canvas.toDataURL('image/jpeg', 0.85);
                    const card = createCard(fileId, i, imgData, isExt, isTar);
                    targetContainer.appendChild(card);
                    if (isTar) targetContainer.appendChild(createInsertDivider());
                    
                    if (i % 5 === 0) updateStatusText(`${i}/${pdf.numPages} ページ描画中...`);
                }
            } catch (err) { alert('PDFの表示に失敗しました。'); }
            hideStatus();
        });
    };

    setupInput('extractInput', 'extract-list', true, false);
    setupInput('sourceInput', 'source-list', false, false);
    setupInput('targetInput', 'target-list', false, true);

    function createCard(fileId, pageNum, imgData, isExt, isTar) {
        const card = document.createElement('div');
        card.className = 'page-card';
        card.innerHTML = `<img src="${imgData}"><div class="page-footer"><span>P.${pageNum}</span></div>`;
        
        if (isExt) {
            const btn = document.createElement('button');
            btn.className = 'btn btn-extract'; btn.innerText = 'この1枚を保存';
            btn.onclick = (e) => { e.stopPropagation(); extractSinglePage(fileId, pageNum); };
            card.querySelector('.page-footer').appendChild(btn);
        } else if (!isTar) {
            card.onclick = () => {
                document.querySelectorAll('#source-list .page-card').forEach(c => c.classList.remove('selected'));
                card.classList.add('selected');
                selectedSourcePage = { fileId, pageNum, imgData };
                document.querySelectorAll('.btn-insert-here').forEach(b => b.classList.add('active'));
            };
        } else {
            const del = document.createElement('button');
            del.className = 'btn-del'; del.innerHTML = '×';
            del.onclick = (e) => { e.stopPropagation(); card.nextSibling.remove(); card.remove(); };
            card.appendChild(del);
        }
        return card;
    }

    function createInsertDivider() {
        const div = document.createElement('div');
        div.className = 'insert-divider';
        const btn = document.createElement('button');
        btn.className = 'btn-insert-here';
        if (selectedSourcePage) btn.classList.add('active');
        btn.innerHTML = '＋ ここに挿入';
        btn.onclick = () => {
            const newCard = createCard(selectedSourcePage.fileId, selectedSourcePage.pageNum, selectedSourcePage.imgData, false, true);
            div.after(newCard, createInsertDivider());
        };
        div.appendChild(btn);
        return div;
    }

    async function extractSinglePage(fileId, pageNum) {
        showStatus('PDF生成中...');
        try {
            const srcPdf = await PDFDocument.load(pdfDataMap.get(fileId), { ignoreEncryption: true });
            const outPdf = await PDFDocument.create();
            const [page] = await outPdf.copyPages(srcPdf, [pageNum - 1]);
            outPdf.addPage(page);
            download(await outPdf.save(), `page_${pageNum}.pdf`);
        } catch (e) { alert('保存に失敗しました。暗号化されている可能性があります。'); }
        hideStatus();
    }

    document.getElementById('saveMergedBtn').addEventListener('click', async () => {
        const items = document.querySelectorAll('#target-list .page-card');
        if (!items.length) return alert('ページがありません');
        showStatus('PDF生成中...');
        try {
            const outPdf = await PDFDocument.create();
            const cache = new Map();
            for (const item of items) {
                const fId = item.parentElement.children === undefined ? null : "dummy"; // dummy check
                // 実際はdatasetから取得
                const realFileId = Array.from(pdfDataMap.keys()).find(k => {
                    // カードを特定するための簡易ロジック（本来はdatasetに保持）
                    return true; 
                });
                // 正確な取得に修正
                const targetFileId = Array.from(document.querySelectorAll('#target-list .page-card')).indexOf(item);
                // datasetから直接取得するように修正
            }
            
            // ループを再構成
            const cards = Array.from(document.querySelectorAll('#target-list .page-card'));
            for (const card of cards) {
                const fId = Array.from(pdfDataMap.keys())[0]; // 簡易化のためMapから取得
                // 正しくは各card生成時にdatasetに入れた値を使う
                const actualFileId = card.querySelector('img').src.includes('data') ? "find" : ""; 
            }

            // --- 修正版ループ ---
            const targetCards = document.querySelectorAll('#target-list .page-card');
            const pdfCache = new Map();
            
            for (const card of targetCards) {
                // カード作成時に保持した情報を再取得（datasetを利用）
                // ※createCard内で dataset.fileId = fileId を設定し忘れていたので内部で補完
                const fId = Array.from(pdfDataMap.keys()).find(k => card.innerHTML.includes('P.')); 
                // 確実に取得するため、createCardを修正してdatasetを付与します（下記参照）
            }
        } catch (e) { alert('エラーが発生しました。'); }
        hideStatus();
    });

    // --- 最終的な結合ロジックの安定化 ---
    async function finalizeMerge() {
        const items = document.querySelectorAll('#target-list .page-card');
        if (!items.length) return alert('ページがありません');
        showStatus('PDF生成中...');
        try {
            const outPdf = await PDFDocument.create();
            const pdfCache = new Map();
            for (const item of items) {
                const fId = item.getAttribute('data-fid');
                const pNum = parseInt(item.getAttribute('data-pnum'));
                if (!pdfCache.has(fId)) {
                    pdfCache.set(fId, await PDFDocument.load(pdfDataMap.get(fId), { ignoreEncryption: true }));
                }
                const [page] = await outPdf.copyPages(pdfCache.get(fId), [pNum - 1]);
                outPdf.addPage(page);
            }
            download(await outPdf.save(), 'merged.pdf');
        } catch (e) { alert('PDFの生成に失敗しました。'); }
        hideStatus();
    }
    document.getElementById('saveMergedBtn').onclick = finalizeMerge;

    // createCardを微修正（dataset付与）
    function createCard(fileId, pageNum, imgData, isExt, isTar) {
        const card = document.createElement('div');
        card.className = 'page-card';
        card.setAttribute('data-fid', fileId);
        card.setAttribute('data-pnum', pageNum);
        card.innerHTML = `<img src="${imgData}"><div class="page-footer"><span>P.${pageNum}</span></div>`;
        // ... (以下、ボタン追加ロジックは上記と同じ)
        if (isExt) {
            const btn = document.createElement('button');
            btn.className = 'btn btn-extract'; btn.innerText = 'この1枚を保存';
            btn.onclick = (e) => { e.stopPropagation(); extractSinglePage(fileId, pageNum); };
            card.querySelector('.page-footer').appendChild(btn);
        } else if (!isTar) {
            card.onclick = () => {
                document.querySelectorAll('#source-list .page-card').forEach(c => c.classList.remove('selected'));
                card.classList.add('selected');
                selectedSourcePage = { fileId, pageNum, imgData };
                document.querySelectorAll('.btn-insert-here').forEach(b => b.classList.add('active'));
            };
        } else {
            const del = document.createElement('button');
            del.className = 'btn-del'; del.innerHTML = '×';
            del.onclick = (e) => { e.stopPropagation(); card.nextSibling.remove(); card.remove(); };
            card.appendChild(del);
        }
        return card;
    }

    function showStatus(t) { document.getElementById('status-text').innerText = t; document.getElementById('status').style.display = 'flex'; }
    function updateStatusText(t) { document.getElementById('status-text').innerText = t; }
    function hideStatus() { document.getElementById('status').style.display = 'none'; }
    function download(bytes, name) {
        const blob = new Blob([bytes], {type: 'application/pdf'});
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob); a.download = name; a.click();
    }
</script>
</body>
</html>
